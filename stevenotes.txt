everything functionality-wise is done for postgresql

I have the text searching down, it looks like you need %San Pedro% to cover
things that will contain that, otherwise "San Pedro" will only match that
exactly (no leading, trailing chars)


otherwise, have DB connections working, will be able to build strings
make sure to use the psycopg docs to sanitize strings

later can consider switching to some kind of ORM or such 

*** TODO Second iteration
- routes for "storymap_metadata" are done
- Adding routes for the other table - "storymap_features"
- 3 new routes or query types
- routes for: *feature_id* *map_id*, and *geom*
- notes about geom: the user will need to pass in a geometry, likely as a minimum
  bounding box. then THAT can be used to query against the geometries in the
  database
- andrew suggested using ST_MAKEENVELOPE and ST_INTERSECTS. the second returns a
  bool, the first sounds like it creates a bounding box. The idea is to return
  all records that would be contained by the bounding box. It sounds like these
  are PostGIS functions, and should have their own documentation
- he also mentioned a ST_AS_GEOJSON function that might be able to generate JSON
  for us easily


TODO add ORDER BY to each of the clauses, today learned that if you do not do
that, queries will return records in the order they were inserted in, so you
need to tell the query what column to order on, otherwise there is no guarantee

make this a dedicated commit when you do this change on ALL areas in code,
should just be the two closing portions of building queries, after the closing
"AND TRUE", OR just replace the and true.... might need to keep it to not break
calls, but you will just add the order by clause, to ensure behavior of what is
returned


current remaining:
1) http://www.postgresonline.com/journal/archives/267-Creating-GeoJSON-Feature-Collections-with-JSON-and-PostGIS-functions.html
some good ideas here about building out the GeoJSON....it looks like the best
way to do it will be manually where you explicitly do selects and assign things
names, and one by one tie the columns to label names etc

the metadata path will not return GeoJSON, just JSON
the features path will need to return GeoJSON

2) second remaining piece is the geometric path...
 should be 4 values, min and max for y and x, to build the box, then find out
 what features would be inside that box

3) wrapping it up final in docker so it's clean and runs automatically on the
exposed port, everything nice and clean fo rthe build process


super helpful update from andrew... the st_asgeojson(geom) call is what
generates the whole type:point Coordinates: .... stuff. Can probably just strip
that out of the big complicated call later on and make all of this so much
cleaner
